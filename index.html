<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ThreeJS 爱心手势控制</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* 防止滚动条 */
            background-color: #000;
            touch-action: none; /* 禁止默认触摸动作 */
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* 右下角的手势控制区 */
        #gesture-pad {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 180px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            backdrop-filter: blur(5px);
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: sans-serif;
            font-size: 14px;
            text-align: center;
            user-select: none; /* 禁止文字选中 */
            pointer-events: auto; /* 允许接收触摸事件 */
        }

        #gesture-pad p {
            pointer-events: none; /* 文字不阻挡触摸 */
            opacity: 0.8;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="gesture-pad">
        <p>在此区域<br>双指缩放<br>单指旋转</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. 初始化场景 ---
        const scene = new THREE.Scene();
        // 添加一点雾化效果，让远处的爱心变暗
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.z = 500; // 初始相机距离

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 2. 制作爱心材质 (使用 Canvas 绘制) ---
        function createHeartTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // 绘制爱心路径
            ctx.beginPath();
            const x = 32, y = 32;
            ctx.moveTo(x, y + 15);
            ctx.bezierCurveTo(x + 20, y - 10, x + 30, y - 25, x, y - 25);
            ctx.bezierCurveTo(x - 30, y - 25, x - 20, y - 10, x, y + 15);
            ctx.fillStyle = '#FF0033'; // 鲜艳的红色
            ctx.fill();

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- 3. 创建粒子系统 ---
        const geometry = new THREE.BufferGeometry();
        const particlesCount = 1000; // 粒子数量
        const positions = [];
        const scales = []; // 让爱心大小不一

        for (let i = 0; i < particlesCount; i++) {
            // 在空间中随机分布
            positions.push((Math.random() * 2 - 1) * 800);
            positions.push((Math.random() * 2 - 1) * 800);
            positions.push((Math.random() * 2 - 1) * 800);
            scales.push(Math.random() * 20 + 10); // 大小范围
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        // 注意：Three.js r128 原生不支持 geometry attribute 直接控制 point size，
        // 这里为了简化代码，我们在材质里统一设置大小，或者通过 shader。
        // 为了最简单实现，我们使用统一材质大小，但利用 map 的透明边缘让它们看起来融合。

        const material = new THREE.PointsMaterial({
            size: 30, 
            map: createHeartTexture(),
            transparent: true,
            opacity: 0.9,
            depthWrite: false, // 防止粒子相互遮挡产生的黑边
            blending: THREE.AdditiveBlending, // 发光叠加效果
            color: 0xff0000
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 4. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            
            // 让粒子群稍微自动转动一点点，增加灵动感
            particles.rotation.y += 0.001;
            particles.rotation.x += 0.0005;

            renderer.render(scene, camera);
        }
        animate();

        // --- 5. 处理窗口大小变化 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 6. 右下角手势控制逻辑 ---
        const pad = document.getElementById('gesture-pad');
        
        let startDist = 0; // 双指初始距离
        let startScale = 1; // 初始缩放比例
        let currentScale = 1; // 当前缩放比例
        
        // 用于单指旋转
        let startX = 0;
        let startY = 0;

        // 获取两点间距离的函数
        function getDistance(touch1, touch2) {
            const dx = touch1.pageX - touch2.pageX;
            const dy = touch1.pageY - touch2.pageY;
            return Math.hypot(dx, dy);
        }

        pad.addEventListener('touchstart', (e) => {
            e.preventDefault(); // 阻止浏览器默认行为

            if (e.touches.length === 2) {
                // 双指：准备缩放
                startDist = getDistance(e.touches[0], e.touches[1]);
                startScale = particles.scale.x; // 记录当前物体的缩放值
            } else if (e.touches.length === 1) {
                // 单指：准备旋转
                startX = e.touches[0].pageX;
                startY = e.touches[0].pageY;
            }
        }, { passive: false });

        pad.addEventListener('touchmove', (e) => {
            e.preventDefault();

            if (e.touches.length === 2) {
                // --- 双指缩放逻辑 ---
                const dist = getDistance(e.touches[0], e.touches[1]);
                if (startDist > 0) {
                    const ratio = dist / startDist;
                    // 限制一下缩放范围，防止太小消失或太大穿模
                    let newScale = startScale * ratio;
                    newScale = Math.max(0.1, Math.min(newScale, 5.0));
                    
                    // 应用缩放
                    particles.scale.set(newScale, newScale, newScale);
                }
            } else if (e.touches.length === 1) {
                // --- 单指旋转逻辑 (额外赠送的功能) ---
                const dx = e.touches[0].pageX - startX;
                const dy = e.touches[0].pageY - startY;
                
                particles.rotation.y += dx * 0.005;
                particles.rotation.x += dy * 0.005;
                
                // 更新起始点，让旋转更平滑
                startX = e.touches[0].pageX;
                startY = e.touches[0].pageY;
            }
        }, { passive: false });

        // --- 兼容 PC 鼠标滚轮缩放 (方便调试) ---
        pad.addEventListener('wheel', (e) => {
            e.preventDefault();
            let scaleFactor = 1 + (e.deltaY * -0.001);
            let newScale = particles.scale.x * scaleFactor;
            newScale = Math.max(0.1, Math.min(newScale, 5.0));
            particles.scale.set(newScale, newScale, newScale);
        });

    </script>
</body>
</html>
